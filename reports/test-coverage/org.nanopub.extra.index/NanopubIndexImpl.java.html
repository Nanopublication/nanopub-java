<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>NanopubIndexImpl.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">nanopub</a> &gt; <a href="index.source.html" class="el_package">org.nanopub.extra.index</a> &gt; <span class="el_source">NanopubIndexImpl.java</span></div><h1>NanopubIndexImpl.java</h1><pre class="source lang-java linenums">package org.nanopub.extra.index;

import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;
import org.eclipse.rdf4j.model.IRI;
import org.eclipse.rdf4j.model.Literal;
import org.eclipse.rdf4j.model.Statement;
import org.eclipse.rdf4j.model.vocabulary.DC;
import org.eclipse.rdf4j.model.vocabulary.DCTERMS;
import org.eclipse.rdf4j.model.vocabulary.RDF;
import org.eclipse.rdf4j.model.vocabulary.RDFS;
import org.nanopub.MalformedNanopubException;
import org.nanopub.Nanopub;
import org.nanopub.NanopubWithNs;
import org.nanopub.vocabulary.NPX;

import java.util.*;

/**
 * Implementation of the NanopubIndex interface, representing a nanopublication index.
 */
public class NanopubIndexImpl implements NanopubIndex, NanopubWithNs {

    private final Nanopub np;
    private final Set&lt;IRI&gt; elementSet;
    private final Set&lt;IRI&gt; subIndexSet;
    private final IRI appendedIndex;
<span class="fc" id="L29">    private boolean isIncompleteIndex = false;</span>

    /**
     * Creates a new NanopubIndexImpl instance from a given Nanopub.
     *
     * @param npIndex the Nanopub to be used as an index
     * @throws org.nanopub.MalformedNanopubException if the Nanopub does not conform to the expected structure of an index
     */
<span class="fc" id="L37">    protected NanopubIndexImpl(Nanopub npIndex) throws MalformedNanopubException {</span>
<span class="fc" id="L38">        this.np = npIndex;</span>
<span class="pc bpc" id="L39" title="1 of 2 branches missed.">        if (!IndexUtils.isIndex(np)) {</span>
<span class="nc" id="L40">            throw new MalformedNanopubException(&quot;Nanopub is not a nanopub index&quot;);</span>
        }
<span class="fc" id="L42">        IRI appendedIndex = null;</span>
<span class="fc" id="L43">        Set&lt;IRI&gt; elementSet = new HashSet&lt;&gt;();</span>
<span class="fc" id="L44">        Set&lt;IRI&gt; subIndexSet = new HashSet&lt;&gt;();</span>
<span class="fc bfc" id="L45" title="All 2 branches covered.">        for (Statement st : np.getAssertion()) {</span>
<span class="fc bfc" id="L46" title="All 2 branches covered.">            if (!st.getSubject().equals(np.getUri())) continue;</span>
<span class="pc bpc" id="L47" title="1 of 2 branches missed.">            if (st.getPredicate().equals(NPX.APPENDS_INDEX)) {</span>
<span class="nc bnc" id="L48" title="All 2 branches missed.">                if (appendedIndex != null) {</span>
<span class="nc" id="L49">                    throw new MalformedNanopubException(&quot;Multiple appends-statements found for index&quot;);</span>
                }
<span class="nc bnc" id="L51" title="All 2 branches missed.">                if (!(st.getObject() instanceof IRI)) {</span>
<span class="nc" id="L52">                    throw new MalformedNanopubException(&quot;URI expected for object of appends-statement&quot;);</span>
                }
<span class="nc" id="L54">                appendedIndex = (IRI) st.getObject();</span>
<span class="pc bpc" id="L55" title="1 of 2 branches missed.">            } else if (st.getPredicate().equals(NPX.INCLUDES_ELEMENT)) {</span>
<span class="pc bpc" id="L56" title="1 of 2 branches missed.">                if (!(st.getObject() instanceof IRI)) {</span>
<span class="nc" id="L57">                    throw new MalformedNanopubException(&quot;Element has to be a URI&quot;);</span>
                }
<span class="fc" id="L59">                elementSet.add((IRI) st.getObject());</span>
<span class="nc bnc" id="L60" title="All 2 branches missed.">            } else if (st.getPredicate().equals(NPX.INCLUDES_SUBINDEX)) {</span>
<span class="nc bnc" id="L61" title="All 2 branches missed.">                if (!(st.getObject() instanceof IRI)) {</span>
<span class="nc" id="L62">                    throw new MalformedNanopubException(&quot;Sub-index has to be a URI&quot;);</span>
                }
<span class="nc" id="L64">                subIndexSet.add((IRI) st.getObject());</span>
            }
<span class="fc" id="L66">        }</span>
<span class="fc bfc" id="L67" title="All 2 branches covered.">        for (Statement st : np.getPubinfo()) {</span>
<span class="fc bfc" id="L68" title="All 2 branches covered.">            if (!st.getSubject().equals(np.getUri())) continue;</span>
<span class="fc bfc" id="L69" title="All 2 branches covered.">            if (!st.getPredicate().equals(RDF.TYPE)) continue;</span>
<span class="pc bpc" id="L70" title="1 of 2 branches missed.">            if (st.getObject().equals(NPX.INCOMPLETE_INDEX)) {</span>
<span class="nc" id="L71">                isIncompleteIndex = true;</span>
            }
<span class="fc" id="L73">        }</span>
<span class="fc" id="L74">        this.appendedIndex = appendedIndex;</span>
<span class="pc bpc" id="L75" title="1 of 2 branches missed.">        if (elementSet.size() + subIndexSet.size() &gt; MAX_SIZE) {</span>
<span class="nc" id="L76">            throw new MalformedNanopubException(&quot;Nanopub index exceeds maximum size&quot;);</span>
        }
<span class="fc" id="L78">        this.elementSet = ImmutableSet.copyOf(elementSet);</span>
<span class="fc" id="L79">        this.subIndexSet = ImmutableSet.copyOf(subIndexSet);</span>
<span class="fc" id="L80">    }</span>

    /**
     * {@inheritDoc}
     * &lt;p&gt;
     * Returns the URI of the nanopublication index.
     */
    @Override
    public IRI getUri() {
<span class="nc" id="L89">        return np.getUri();</span>
    }

    /**
     * {@inheritDoc}
     * &lt;p&gt;
     * Returns the URI of the head of the nanopublication.
     */
    @Override
    public IRI getHeadUri() {
<span class="nc" id="L99">        return np.getHeadUri();</span>
    }

    /**
     * {@inheritDoc}
     * &lt;p&gt;
     * Returns the set of statements that form the head of the nanopublication.
     */
    @Override
    public Set&lt;Statement&gt; getHead() {
<span class="fc" id="L109">        return np.getHead();</span>
    }

    /**
     * {@inheritDoc}
     * &lt;p&gt;
     * Returns the URI of the assertion information of the nanopublication.
     */
    @Override
    public IRI getAssertionUri() {
<span class="nc" id="L119">        return np.getAssertionUri();</span>
    }

    /**
     * {@inheritDoc}
     * &lt;p&gt;
     * Returns the set of statements that form the assertion of the nanopublication.
     */
    @Override
    public Set&lt;Statement&gt; getAssertion() {
<span class="fc" id="L129">        return np.getAssertion();</span>
    }

    /**
     * {@inheritDoc}
     * &lt;p&gt;
     * Returns the URI of the provenance information of the nanopublication.
     */
    @Override
    public IRI getProvenanceUri() {
<span class="nc" id="L139">        return np.getProvenanceUri();</span>
    }

    /**
     * {@inheritDoc}
     * &lt;p&gt;
     * Returns the set of statements that provide provenance information about the nanopublication.
     */
    @Override
    public Set&lt;Statement&gt; getProvenance() {
<span class="fc" id="L149">        return np.getProvenance();</span>
    }

    /**
     * {@inheritDoc}
     * &lt;p&gt;
     * Returns the URI of the publication information of the nanopublication.
     */
    @Override
    public IRI getPubinfoUri() {
<span class="nc" id="L159">        return np.getPubinfoUri();</span>
    }

    /**
     * {@inheritDoc}
     * &lt;p&gt;
     * Returns the set of statements that provide publication information about the nanopublication.
     */
    @Override
    public Set&lt;Statement&gt; getPubinfo() {
<span class="fc" id="L169">        return np.getPubinfo();</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public Set&lt;IRI&gt; getGraphUris() {
<span class="nc" id="L177">        return np.getGraphUris();</span>
    }

    /**
     * {@inheritDoc}
     * &lt;p&gt;
     * Returns the creation time of the nanopublication.
     */
    @Override
    public Calendar getCreationTime() {
<span class="nc" id="L187">        return np.getCreationTime();</span>
    }

    /**
     * {@inheritDoc}
     * &lt;p&gt;
     * Returns a set of URIs that are defined as authors in the nanopublication.
     */
    @Override
    public Set&lt;IRI&gt; getAuthors() {
<span class="nc" id="L197">        return np.getAuthors();</span>
    }

    /**
     * {@inheritDoc}
     * &lt;p&gt;
     * Returns a set of URIs that are defined as creators in the nanopublication.
     */
    @Override
    public Set&lt;IRI&gt; getCreators() {
<span class="nc" id="L207">        return np.getCreators();</span>
    }

    /**
     * {@inheritDoc}
     * &lt;p&gt;
     * Returns the count of triples in the nanopublication.
     */
    @Override
    public int getTripleCount() {
<span class="nc" id="L217">        return np.getTripleCount();</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public long getByteCount() {
<span class="nc" id="L225">        return np.getByteCount();</span>
    }

    /**
     * {@inheritDoc}
     * &lt;p&gt;
     * Returns a set of URIs that are included as elements in the nanopublication index.
     */
    @Override
    public Set&lt;IRI&gt; getElements() {
<span class="fc" id="L235">        return elementSet;</span>
    }

    /**
     * {@inheritDoc}
     * &lt;p&gt;
     * Returns a set of sub-indexes that this nanopublication index includes.
     */
    @Override
    public Set&lt;IRI&gt; getSubIndexes() {
<span class="fc" id="L245">        return subIndexSet;</span>
    }

    /**
     * {@inheritDoc}
     * &lt;p&gt;
     * Returns the URI of the index that this nanopublication appends to.
     */
    @Override
    public IRI getAppendedIndex() {
<span class="fc" id="L255">        return appendedIndex;</span>
    }

    /**
     * {@inheritDoc}
     * &lt;p&gt;
     * Checks if the nanopublication index is incomplete.
     */
    @Override
    public boolean isIncomplete() {
<span class="fc" id="L265">        return isIncompleteIndex;</span>
    }

    /**
     * {@inheritDoc}
     * &lt;p&gt;
     * Returns a list of namespace prefixes used in the nanopublication.
     */
    @Override
    public List&lt;String&gt; getNsPrefixes() {
<span class="pc bpc" id="L275" title="1 of 2 branches missed.">        if (np instanceof NanopubWithNs) {</span>
<span class="fc" id="L276">            return ((NanopubWithNs) np).getNsPrefixes();</span>
        } else {
<span class="nc" id="L278">            return ImmutableList.of();</span>
        }
    }

    /**
     * {@inheritDoc}
     * &lt;p&gt;
     * Returns the namespace URI for a given prefix.
     */
    @Override
    public String getNamespace(String prefix) {
<span class="pc bpc" id="L289" title="1 of 2 branches missed.">        if (np instanceof NanopubWithNs) {</span>
<span class="fc" id="L290">            return ((NanopubWithNs) np).getNamespace(prefix);</span>
        } else {
<span class="nc" id="L292">            return null;</span>
        }
    }

    /**
     * {@inheritDoc}
     * &lt;p&gt;
     * Returns the name of the nanopublication, which is typically derived from the title statement in the pubinfo.
     */
    @Override
    public String getName() {
<span class="nc bnc" id="L303" title="All 2 branches missed.">        for (Statement st : np.getPubinfo()) {</span>
<span class="nc bnc" id="L304" title="All 2 branches missed.">            if (!st.getSubject().equals(np.getUri())) continue;</span>
<span class="nc bnc" id="L305" title="All 4 branches missed.">            if (!st.getPredicate().equals(DC.TITLE) || st.getPredicate().equals(DCTERMS.TITLE)) continue;</span>
<span class="nc bnc" id="L306" title="All 2 branches missed.">            if (!(st.getObject() instanceof Literal)) continue;</span>
<span class="nc" id="L307">            return ((Literal) st.getObject()).getLabel();</span>
        }
<span class="nc" id="L309">        return null;</span>
    }

    /**
     * {@inheritDoc}
     * &lt;p&gt;
     * Returns the description of the nanopublication.
     */
    @Override
    public String getDescription() {
<span class="nc bnc" id="L319" title="All 2 branches missed.">        for (Statement st : np.getPubinfo()) {</span>
<span class="nc bnc" id="L320" title="All 2 branches missed.">            if (!st.getSubject().equals(np.getUri())) continue;</span>
<span class="nc bnc" id="L321" title="All 4 branches missed.">            if (!st.getPredicate().equals(DC.DESCRIPTION) || st.getPredicate().equals(DCTERMS.DESCRIPTION)) continue;</span>
<span class="nc bnc" id="L322" title="All 2 branches missed.">            if (!(st.getObject() instanceof Literal)) continue;</span>
<span class="nc" id="L323">            return ((Literal) st.getObject()).getLabel();</span>
        }
<span class="nc" id="L325">        return null;</span>
    }

    /**
     * Returns a set of URIs that are referenced in the &quot;seeAlso&quot; statements of the nanopublication index.
     *
     * @return a set of IRI objects representing the &quot;seeAlso&quot; URIs
     */
    public Set&lt;IRI&gt; getSeeAlsoUris() {
<span class="nc" id="L334">        Set&lt;IRI&gt; seeAlsoUris = new HashSet&lt;&gt;();</span>
<span class="nc bnc" id="L335" title="All 2 branches missed.">        for (Statement st : getPubinfo()) {</span>
<span class="nc bnc" id="L336" title="All 2 branches missed.">            if (!st.getSubject().equals(getUri())) continue;</span>
<span class="nc bnc" id="L337" title="All 2 branches missed.">            if (!st.getPredicate().equals(RDFS.SEEALSO)) continue;</span>
<span class="nc bnc" id="L338" title="All 2 branches missed.">            if (!(st.getObject() instanceof IRI)) continue;</span>
<span class="nc" id="L339">            seeAlsoUris.add((IRI) st.getObject());</span>
<span class="nc" id="L340">        }</span>
<span class="nc" id="L341">        return seeAlsoUris;</span>
    }

    /**
     * {@inheritDoc}
     * &lt;p&gt;
     * Removes unused namespace prefixes from the nanopublication.
     */
    @Override
    public void removeUnusedPrefixes() {
<span class="nc bnc" id="L351" title="All 2 branches missed.">        if (np instanceof NanopubWithNs) {</span>
<span class="nc" id="L352">            ((NanopubWithNs) np).removeUnusedPrefixes();</span>
        }
<span class="nc" id="L354">    }</span>

    /**
     * {@inheritDoc}
     * &lt;p&gt;
     * Returns a map of namespace prefixes to their corresponding URIs used in the nanopublication.
     */
    @Override
    public Map&lt;String, String&gt; getNs() {
<span class="nc bnc" id="L363" title="All 2 branches missed.">        if (np instanceof NanopubWithNs) {</span>
<span class="nc" id="L364">            return ((NanopubWithNs) np).getNs();</span>
        } else {
<span class="nc" id="L366">            return ImmutableMap.of();</span>
        }
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public boolean equals(Object o) {
<span class="pc bpc" id="L375" title="2 of 4 branches missed.">        if (o == null || getClass() != o.getClass()) return false;</span>
<span class="fc" id="L376">        NanopubIndexImpl that = (NanopubIndexImpl) o;</span>
<span class="fc" id="L377">        return Objects.equals(np, that.np);</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public int hashCode() {
<span class="nc" id="L385">        return Objects.hashCode(np);</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>