<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>LegacySignNanopub.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">nanopub</a> &gt; <a href="index.source.html" class="el_package">org.nanopub.extra.security</a> &gt; <span class="el_source">LegacySignNanopub.java</span></div><h1>LegacySignNanopub.java</h1><pre class="source lang-java linenums">package org.nanopub.extra.security;

import com.beust.jcommander.JCommander;
import com.beust.jcommander.ParameterException;
import jakarta.xml.bind.DatatypeConverter;
import net.trustyuri.TrustyUriException;
import net.trustyuri.TrustyUriResource;
import net.trustyuri.TrustyUriUtils;
import org.apache.commons.io.IOUtils;
import org.eclipse.rdf4j.model.IRI;
import org.eclipse.rdf4j.rio.*;
import org.nanopub.*;

import java.io.*;
import java.nio.charset.StandardCharsets;
import java.security.*;
import java.security.spec.InvalidKeySpecException;
import java.security.spec.KeySpec;
import java.security.spec.PKCS8EncodedKeySpec;
import java.security.spec.X509EncodedKeySpec;
import java.util.ArrayList;
import java.util.List;
import java.util.zip.GZIPOutputStream;

/**
 * Legacy command-line tool to sign nanopubs.
 */
public class LegacySignNanopub {

<span class="nc" id="L30">    @com.beust.jcommander.Parameter(description = &quot;input-nanopubs&quot;, required = true)</span>
    private List&lt;File&gt; inputNanopubs = new ArrayList&lt;&gt;();

<span class="nc" id="L33">    @com.beust.jcommander.Parameter(names = &quot;-k&quot;, description = &quot;Path and file name of key files&quot;)</span>
    private String keyFilename = &quot;~/.nanopub/id_dsa&quot;;

<span class="nc" id="L36">    @com.beust.jcommander.Parameter(names = &quot;-v&quot;, description = &quot;Verbose&quot;)</span>
    private boolean verbose = false;

    /**
     * Main method to run the command-line tool.
     *
     * @param args command-line arguments
     * @throws java.io.IOException if an I/O error occurs
     */
    public static void main(String[] args) throws IOException {
<span class="nc" id="L46">        NanopubImpl.ensureLoaded();</span>
<span class="nc" id="L47">        LegacySignNanopub obj = new LegacySignNanopub();</span>
<span class="nc" id="L48">        JCommander jc = new JCommander(obj);</span>
        try {
<span class="nc" id="L50">            jc.parse(args);</span>
<span class="nc" id="L51">        } catch (ParameterException ex) {</span>
<span class="nc" id="L52">            jc.usage();</span>
<span class="nc" id="L53">            System.exit(1);</span>
<span class="nc" id="L54">        }</span>
        try {
<span class="nc" id="L56">            obj.run();</span>
<span class="nc" id="L57">        } catch (Exception ex) {</span>
<span class="nc" id="L58">            ex.printStackTrace();</span>
<span class="nc" id="L59">            System.exit(1);</span>
<span class="nc" id="L60">        }</span>
<span class="nc" id="L61">    }</span>

    private KeyPair key;

<span class="nc" id="L65">    private LegacySignNanopub() {</span>
<span class="nc" id="L66">    }</span>

    private void run() throws Exception {
<span class="nc" id="L69">        key = loadKey(keyFilename);</span>
<span class="nc bnc" id="L70" title="All 2 branches missed.">        for (File inputFile : inputNanopubs) {</span>
<span class="nc" id="L71">            File outFile = new File(inputFile.getParent(), &quot;signed.&quot; + inputFile.getName());</span>
            final OutputStream out;
<span class="nc bnc" id="L73" title="All 2 branches missed.">            if (inputFile.getName().matches(&quot;.*\\.(gz|gzip)&quot;)) {</span>
<span class="nc" id="L74">                out = new GZIPOutputStream(new FileOutputStream(outFile));</span>
            } else {
<span class="nc" id="L76">                out = new FileOutputStream(outFile);</span>
            }
<span class="nc" id="L78">            final RDFFormat format = new TrustyUriResource(inputFile).getFormat(RDFFormat.TRIG);</span>
<span class="nc" id="L79">            MultiNanopubRdfHandler.process(format, inputFile, np -&gt; {</span>
                try {
<span class="nc" id="L81">                    np = writeAsSignedTrustyNanopub(np, format, key, out);</span>
<span class="nc bnc" id="L82" title="All 2 branches missed.">                    if (verbose) {</span>
<span class="nc" id="L83">                        System.out.println(&quot;Nanopub URI: &quot; + np.getUri());</span>
                    }
<span class="nc" id="L85">                } catch (RDFHandlerException | SignatureException | InvalidKeyException | TrustyUriException ex) {</span>
<span class="nc" id="L86">                    ex.printStackTrace();</span>
<span class="nc" id="L87">                    throw new RuntimeException(ex);</span>
<span class="nc" id="L88">                }</span>
<span class="nc" id="L89">            });</span>
<span class="nc" id="L90">            out.close();</span>
<span class="nc" id="L91">        }</span>
<span class="nc" id="L92">    }</span>

    /**
     * Signs a Nanopub and transforms it into a Trusty URI format.
     *
     * @param nanopub the Nanopub to sign and transform
     * @param key     the KeyPair used for signing
     * @return the signed and transformed Nanopub
     * @throws net.trustyuri.TrustyUriException  if there is an issue with the Trusty URI format
     * @throws java.security.InvalidKeyException if the provided key is invalid
     * @throws java.security.SignatureException  if there is an issue with the signature process
     */
    public static Nanopub signAndTransform(Nanopub nanopub, KeyPair key) throws TrustyUriException, InvalidKeyException, SignatureException {
<span class="nc" id="L105">        return signAndTransform(nanopub, key, null);</span>
    }

    /**
     * Signs a Nanopub and transforms it into a Trusty URI format.
     *
     * @param nanopub the Nanopub to sign and transform
     * @param key     the KeyPair used for signing
     * @param signer  the IRI of the signer
     * @return the signed and transformed Nanopub
     * @throws net.trustyuri.TrustyUriException  if there is an issue with the Trusty URI format
     * @throws java.security.InvalidKeyException if the provided key is invalid
     * @throws java.security.SignatureException  if there is an issue with the signature process
     */
    public static Nanopub signAndTransform(Nanopub nanopub, KeyPair key, IRI signer) throws TrustyUriException, InvalidKeyException, SignatureException {
<span class="nc bnc" id="L120" title="All 2 branches missed.">        if (TrustyUriUtils.getArtifactCode(nanopub.getUri().toString()) != null) {</span>
<span class="nc" id="L121">            throw new SignatureException(&quot;Seems to have trusty URI before signing: &quot; + nanopub.getUri());</span>
        }
<span class="nc bnc" id="L123" title="All 2 branches missed.">        if (SignatureUtils.seemsToHaveSignature(nanopub)) {</span>
<span class="nc" id="L124">            throw new SignatureException(&quot;Seems to have signature before signing: &quot; + nanopub.getUri());</span>
        }
<span class="nc bnc" id="L126" title="All 2 branches missed.">        if (nanopub instanceof NanopubWithNs) {</span>
<span class="nc" id="L127">            ((NanopubWithNs) nanopub).removeUnusedPrefixes();</span>
        }
        try {
<span class="nc" id="L130">            return LegacySignatureUtils.createSignedNanopub(nanopub, key, signer);</span>
<span class="nc" id="L131">        } catch (Exception ex) {</span>
<span class="nc" id="L132">            ex.printStackTrace();</span>
<span class="nc" id="L133">            throw new RuntimeException(ex);</span>
        }
    }

    /**
     * Signs and transforms multiple Nanopubs from an InputStream into a Trusty URI format.
     *
     * @param format the RDF format of the input Nanopubs
     * @param file   the input file containing multiple Nanopubs
     * @param key    the KeyPair used for signing
     * @param out    the OutputStream to write the signed Nanopubs to
     * @throws java.io.IOException                       if an I/O error occurs
     * @throws org.eclipse.rdf4j.rio.RDFParseException   if there is an error parsing the RDF data
     * @throws org.eclipse.rdf4j.rio.RDFHandlerException if there is an error handling the RDF data
     * @throws org.nanopub.MalformedNanopubException     if a Nanopub is malformed
     */
    public static void signAndTransformMultiNanopub(final RDFFormat format, File file, KeyPair key, final OutputStream out) throws IOException, RDFParseException, RDFHandlerException, MalformedNanopubException {
<span class="nc" id="L150">        InputStream in = new FileInputStream(file);</span>
<span class="nc" id="L151">        signAndTransformMultiNanopub(format, in, key, out);</span>
<span class="nc" id="L152">    }</span>

    /**
     * Signs and transforms multiple Nanopubs from an InputStream into a Trusty URI format.
     *
     * @param format the RDF format of the input Nanopubs
     * @param in     the InputStream containing multiple Nanopubs
     * @param key    the KeyPair used for signing
     * @param out    the OutputStream to write the signed Nanopubs to
     * @throws java.io.IOException                       if an I/O error occurs
     * @throws org.eclipse.rdf4j.rio.RDFParseException   if there is an error parsing the RDF data
     * @throws org.eclipse.rdf4j.rio.RDFHandlerException if there is an error handling the RDF data
     * @throws org.nanopub.MalformedNanopubException     if a Nanopub is malformed
     */
    public static void signAndTransformMultiNanopub(final RDFFormat format, InputStream in, final KeyPair key, final OutputStream out) throws IOException, RDFParseException, RDFHandlerException, MalformedNanopubException {
<span class="nc" id="L167">        MultiNanopubRdfHandler.process(format, in, np -&gt; {</span>
            try {
<span class="nc" id="L169">                writeAsSignedTrustyNanopub(np, format, key, out);</span>
<span class="nc" id="L170">            } catch (RDFHandlerException | SignatureException | InvalidKeyException | TrustyUriException ex) {</span>
<span class="nc" id="L171">                ex.printStackTrace();</span>
<span class="nc" id="L172">                throw new RuntimeException(ex);</span>
<span class="nc" id="L173">            }</span>
<span class="nc" id="L174">        });</span>
<span class="nc" id="L175">        out.close();</span>
<span class="nc" id="L176">    }</span>

    /**
     * Writes a signed Nanopub in Trusty URI format to an OutputStream.
     *
     * @param np     the Nanopub to write
     * @param format the RDF format to use for writing
     * @param key    the KeyPair used for signing
     * @param out    the OutputStream to write the signed Nanopub to
     * @return the signed Nanopub
     * @throws org.eclipse.rdf4j.rio.RDFHandlerException if there is an error handling the RDF data
     * @throws net.trustyuri.TrustyUriException          if there is an issue with the Trusty URI format
     * @throws java.security.InvalidKeyException         if the provided key is invalid
     * @throws java.security.SignatureException          if there is an issue with the signature process
     */
    public static Nanopub writeAsSignedTrustyNanopub(Nanopub np, RDFFormat format, KeyPair key, OutputStream out) throws RDFHandlerException, TrustyUriException, InvalidKeyException, SignatureException {
<span class="nc" id="L192">        np = signAndTransform(np, key);</span>
<span class="nc" id="L193">        RDFWriter w = Rio.createWriter(format, new OutputStreamWriter(out, StandardCharsets.UTF_8));</span>
<span class="nc" id="L194">        NanopubUtils.propagateToHandler(np, w);</span>
<span class="nc" id="L195">        return np;</span>
    }

    /**
     * Loads a KeyPair from a specified key file.
     *
     * @param keyFilename the path to the key file
     * @return the loaded KeyPair
     * @throws java.security.NoSuchAlgorithmException     if the DSA algorithm is not available
     * @throws java.io.IOException                        if an I/O error occurs while reading the key file
     * @throws java.security.spec.InvalidKeySpecException if the key specification is invalid
     */
    public static KeyPair loadKey(String keyFilename) throws NoSuchAlgorithmException, IOException, InvalidKeySpecException {
<span class="nc" id="L208">        keyFilename = SignatureUtils.getFullFilePath(keyFilename);</span>
<span class="nc" id="L209">        KeyFactory kf = KeyFactory.getInstance(&quot;DSA&quot;);</span>
<span class="nc" id="L210">        byte[] privateKeyBytes = DatatypeConverter.parseBase64Binary(IOUtils.toString(new FileInputStream(keyFilename), StandardCharsets.UTF_8));</span>
<span class="nc" id="L211">        KeySpec privateSpec = new PKCS8EncodedKeySpec(privateKeyBytes);</span>
<span class="nc" id="L212">        PrivateKey privateKey = kf.generatePrivate(privateSpec);</span>
<span class="nc" id="L213">        byte[] publicKeyBytes = DatatypeConverter.parseBase64Binary(IOUtils.toString(new FileInputStream(keyFilename + &quot;.pub&quot;), StandardCharsets.UTF_8));</span>
<span class="nc" id="L214">        KeySpec publicSpec = new X509EncodedKeySpec(publicKeyBytes);</span>
<span class="nc" id="L215">        PublicKey publicKey = kf.generatePublic(publicSpec);</span>
<span class="nc" id="L216">        return new KeyPair(publicKey, privateKey);</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>